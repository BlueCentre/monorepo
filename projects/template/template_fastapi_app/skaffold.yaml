apiVersion: skaffold/v4beta6
kind: Config
metadata:
  name: template-fastapi-app

build:
  artifacts:
    - image: template-fastapi-app
      custom:
        buildCommand: |
          # Navigate to monorepo root first
          MONOREPO_ROOT=$(cd ../../.. && pwd)
          cd $MONOREPO_ROOT

          # Run code tests before building artifacts
          bazel test //projects/template/template_fastapi_app/...

          # Then build the tarball
          bazel build //projects/template/template_fastapi_app:image_tarball

          # Extract the tarball
          TEMP_DIR=$(mktemp -d)
          tar -xf bazel-bin/projects/template/template_fastapi_app/image_tarball.tar -C $TEMP_DIR

          # Verify contents were extracted correctly
          echo "Extracted files:"
          ls -la $TEMP_DIR

          # If Dockerfile doesn't exist, rename Dockerfile.bazel to Dockerfile
          if [ ! -f "$TEMP_DIR/Dockerfile" ] && [ -f "$TEMP_DIR/Dockerfile.bazel" ]; then
            echo "Renaming Dockerfile.bazel to Dockerfile"
            cp $TEMP_DIR/Dockerfile.bazel $TEMP_DIR/Dockerfile
          fi

          # Build the Docker image
          docker build -t $IMAGE $TEMP_DIR

          # Clean up
          rm -rf $TEMP_DIR
        dependencies:
          paths:
            - "**/*"
  local:
    push: false
    useBuildkit: false

manifests:
  rawYaml:
    - kubernetes/bootstrap/rbac.yaml
    - kubernetes/namespace.yaml
    - kubernetes/db-migrations-job.yaml  # Include our migrations job
    - kubernetes/*.yaml  # Include all other Kubernetes resources

deploy:
  kubectl: {}
  # Add post-deployment verification for database initialization
  statusCheck: true

customActions:
  - name: enable-istio-injection
    containers:
      - name: kubectl-istio-setup
        image: bitnami/kubectl:latest
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "=== SETTING UP ISTIO INTEGRATION ==="
            
            # Create namespace if it doesn't exist
            kubectl get namespace template-fastapi-app || kubectl create namespace template-fastapi-app
            
            # Enable Istio injection on the namespace
            echo "Enabling Istio injection on namespace template-fastapi-app..."
            kubectl label namespace template-fastapi-app istio-injection=enabled --overwrite
            
            # Check if Istio is installed
            if ! kubectl get namespace istio-system &>/dev/null; then
              echo "WARNING: Istio doesn't appear to be installed in the cluster."
              echo "Rate limiting functionality will not work without Istio."
              echo "Consider installing Istio with: istioctl install --set profile=demo"
            else
              echo "Istio detected in the cluster."
            fi
    executionMode:
      kubernetesCluster: {}

verify:
  - name: smoke-test
    container:
      name: curl-smoke-test
      image: curlimages/curl:latest
      command: ["/bin/sh", "-c"]
      args:
        - |
          echo "Waiting for application to be ready..."
          sleep 10

          MAX_RETRIES=2
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -le $MAX_RETRIES ] && [ "$SUCCESS" = false ]; do
            SLEEP_DURATION=$((RANDOM % 5 + 5)) # Sleep between 5 and 10 seconds
            echo "Running smoke test (attempt $(($RETRY_COUNT+1))/$((MAX_RETRIES+1)))..."

            # Test health endpoint
            echo "Testing health endpoint..."
            HEALTH_RESPONSE=$(curl -s "${HEALTH_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/health}")
            echo "Health response: $HEALTH_RESPONSE"

            if echo "$HEALTH_RESPONSE" | grep -q "ok"; then
              echo "Health check passed!"

              # Test login endpoint
              echo "Testing login endpoint..."
              LOGIN_RESPONSE=$(curl -s -X 'POST' "${LOGIN_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/login/access-token}" -H 'Content-Type: application/x-www-form-urlencoded' -d 'username=admin@example.com&password=admin')
              echo "Login response: $LOGIN_RESPONSE"

              if echo "$LOGIN_RESPONSE" | grep -q "access_token"; then
                echo "==============================================" 
                echo "Login successful, authentication token received!"
                echo "=============================================="

                # Extract the token
                TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)

                # Test users endpoint
                echo "Testing users endpoint..."
                USERS_RESPONSE=$(curl -s -X 'GET' "${USERS_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/users/}" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN")
                echo "Users response: $USERS_RESPONSE"

                if echo "$USERS_RESPONSE" | grep -q "admin@example.com"; then
                  echo "Users endpoint test passed!"

                  # Test key management endpoint
                  echo "Testing key management status endpoint..."
                  KEY_MGMT_RESPONSE=$(curl -s -X 'GET' "${KEY_MGMT_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/key-management/status}" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN")
                  echo "Key management status response: $KEY_MGMT_RESPONSE"

                  if echo "$KEY_MGMT_RESPONSE" | grep -q "jwt_keys"; then
                    echo "Key management status test passed!"
                    SUCCESS=true
                  else
                    echo "Key management status test failed!"
                  fi
                else
                  echo "Users endpoint test failed!"
                fi
              else
                echo "Login test failed - could not get authentication token!"
              fi
            else
              echo "Health check failed!"
            fi

            if [ "$SUCCESS" = false ]; then
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -le $MAX_RETRIES ]; then
                echo "Smoke test failed, retrying in 10 seconds..."
                sleep 10
              else
                echo "Smoke test failed after $((MAX_RETRIES+1)) attempts! Last error: $?"
                exit 1
              fi
            fi
          done

          # Final success message
          if [ "$SUCCESS" = true ]; then
            echo "API verification successful! All tests passed."
            exit 0
          else
            echo "API verification failed!"
            exit 1
          fi
    executionMode:
      kubernetesCluster: {}

portForward:
  - resourceType: service
    resourceName: template-fastapi-app
    port: 80
    localPort: 8000
  - resourceType: service
    resourceName: postgres
    port: 5432
    localPort: 5432
  - resourceType: service
    resourceName: otel-collector
    port: 4317
    localPort: 4317
  - resourceType: service
    resourceName: otel-collector
    port: 16686
    localPort: 16686

profiles:
  - name: dev
    activation:
      - command: dev
    patches:
      - op: add
        path: /build/local/push
        value: false
      - op: add
        path: /deploy/kubectl/flags
        value:
          apply:
            - --validate=false
            - --force=true
            
  - name: run
    activation:
      - command: run
  
  - name: istio-rate-limit
    patches:
      - op: add
        path: /manifests/rawYaml
        value:
          # Standard application resources
          - kubernetes/namespace.yaml
          - kubernetes/db-migrations-job.yaml
          - kubernetes/*.yaml
          # Istio resources for template-fastapi-app namespace
          - kubernetes/istio/rbac.yaml
          - kubernetes/istio/enable-istio-job.yaml
          - kubernetes/istio/namespace.yaml
          - kubernetes/istio/virtual-service.yaml
          - kubernetes/istio/rate-limit-handler.yaml
      - op: add
        path: /deploy/kubectl/flags
        value:
          apply:
            - --validate=false
      - op: add
        path: /verify
        value:
          - name: verify-rate-limiting
            container:
              name: verify-rate-limiting
              image: curlimages/curl:latest
              command: ["/bin/sh", "-c"]
              args:
                - |
                  echo "Waiting for application and Istio to be ready..."
                  sleep 15

                  # Function to make requests and check for rate limiting
                  test_rate_limiting() {
                    local endpoint="$1"
                    local expected_429="$2"
                    local max_attempts=20
                    local count_429=0

                    echo "Testing rate limiting on endpoint: $endpoint"
                    echo "Making $max_attempts rapid requests..."

                    # Try different service addressing methods
                    SERVICE_URL=""

                    # Test health endpoint
                    echo "Testing health endpoint..."
                    HEALTH_RESPONSE=$(curl -s "${HEALTH_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/health}")
                    echo "Health response: $HEALTH_RESPONSE"

                    if echo "$HEALTH_RESPONSE" | grep -q "ok"; then
                      echo "Health check passed!"

                      # Test login endpoint
                      echo "Testing login endpoint..."
                      LOGIN_RESPONSE=$(curl -s -X 'POST' "${LOGIN_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/login/access-token}" -H 'Content-Type: application/x-www-form-urlencoded' -d 'username=admin@example.com&password=admin')
                      echo "Login response: $LOGIN_RESPONSE"

                      if echo "$LOGIN_RESPONSE" | grep -q "access_token"; then
                        echo "==============================================" 
                        echo "Login successful, authentication token received!"
                        echo "=============================================="

                        # Extract the token
                        TOKEN=$(echo "$LOGIN_RESPONSE" | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)

                        # Test users endpoint
                        echo "Testing users endpoint..."
                        USERS_RESPONSE=$(curl -s -X 'GET' "${USERS_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/users/}" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN")
                        echo "Users response: $USERS_RESPONSE"

                        if echo "$USERS_RESPONSE" | grep -q "admin@example.com"; then
                          echo "Users endpoint test passed!"

                          # Test key management endpoint
                          echo "Testing key management status endpoint..."
                          KEY_MGMT_RESPONSE=$(curl -s -X 'GET' "${KEY_MGMT_ENDPOINT:-http://template-fastapi-app.template-fastapi-app.svc.cluster.local/api/v1/key-management/status}" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN")
                          echo "Key management status response: $KEY_MGMT_RESPONSE"

                          if echo "$KEY_MGMT_RESPONSE" | grep -q "jwt_keys"; then
                            echo "Key management status test passed!"
                            SUCCESS=true
                          else
                            echo "Key management status test failed!"
                          fi
                        else
                          echo "Users endpoint test failed!"
                        fi


                        # ---

                        # Try first URL format
                        echo "Trying URL: http://template-fastapi-app/$endpoint"
                        response=$(curl -s -o /dev/null -w "%{http_code}" "http://template-fastapi-app/$endpoint/" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN" || echo "000")
                        if [ "$response" = "200" ] || [ "$response" = "401" ] || [ "$response" = "403" ] || [ "$response" = "429" ]; then
                          SERVICE_URL="http://template-fastapi-app/$endpoint/"
                          echo "Found working service URL: $SERVICE_URL"
                        else
                          # Try second URL format
                          echo "Trying URL: http://template-fastapi-app.template-fastapi-app/$endpoint"
                          response=$(curl -s -o /dev/null -w "%{http_code}" "http://template-fastapi-app.template-fastapi-app/$endpoint/" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN" || echo "000")
                          if [ "$response" = "200" ] || [ "$response" = "401" ] || [ "$response" = "403" ] || [ "$response" = "429" ]; then
                            SERVICE_URL="http://template-fastapi-app.template-fastapi-app/$endpoint/"
                            echo "Found working service URL: $SERVICE_URL"
                          else
                            # Try third URL format
                            echo "Trying URL: http://template-fastapi-app.template-fastapi-app.svc.cluster.local/$endpoint"
                            response=$(curl -s -o /dev/null -w "%{http_code}" "http://template-fastapi-app.template-fastapi-app.svc.cluster.local/$endpoint/" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN" || echo "000")
                            if [ "$response" = "200" ] || [ "$response" = "307" ] || [ "$response" = "401" ] || [ "$response" = "403" ] || [ "$response" = "429" ]; then
                              SERVICE_URL="http://template-fastapi-app.template-fastapi-app.svc.cluster.local/$endpoint/"
                              echo "Found working service URL: $SERVICE_URL"
                            fi
                          fi
                        fi

                        if [ -z "$SERVICE_URL" ]; then
                          echo "❌ Could not find a working service URL"
                          return 1
                        fi

                        for i in $(seq 1 $max_attempts); do
                          echo "Request $i to $SERVICE_URL"
                          response=$(curl -s -o /dev/null -w "%{http_code}" "$SERVICE_URL" -H 'accept: application/json' -H "Authorization: Bearer $TOKEN" || echo "000")
                          echo "Response code: $response"

                          if [ "$response" = "429" ]; then
                            count_429=$((count_429 + 1))
                            echo "Got rate limited (429)"
                          fi

                          # Small delay to avoid overwhelming the service
                          sleep 0.1
                        done

                        echo "Received $count_429 rate limiting responses (429) out of $max_attempts requests"

                        if [ $count_429 -ge $expected_429 ]; then
                          echo "✅ Rate limiting is working as expected for $endpoint"
                          return 0
                        else
                          echo "❌ Rate limiting is NOT working as expected for $endpoint"
                          echo "Expected at least $expected_429 rate limiting responses, but got $count_429"
                          return 1
                        fi
                      fi
                    fi
                  }

                  # Test API endpoint that should be rate limited
                  if ! test_rate_limiting "api/v1/items" 5; then
                    echo "Rate limiting verification failed for API endpoint"
                    exit 1
                  fi

                  # Test health endpoint that should NOT be rate limited
                  if test_rate_limiting "health" 1; then
                    echo "Health endpoint is being rate limited when it shouldn't be"
                    exit 1
                  else
                    echo "✅ Health endpoint is correctly NOT being rate limited"
                  fi

                  echo "✅ All rate limiting verification tests passed!"
                  exit 0
            executionMode:
              kubernetesCluster: {}
# - name: disable-istio
#   patches:
#     - op: add
#       path: /manifests/rawYaml
#       value:
#         # Standard application resources only
#         - kubernetes/namespace.yaml
#         - kubernetes/db-migrations-job.yaml
#         - kubernetes/*.yaml
#         - kubernetes/istio/rbac.yaml
#         - kubernetes/istio/disable-istio-job.yaml
#     - op: add
#       path: /deploy/kubectl/flags
#       value:
#         apply:
#           - --validate=false
# ---
# apiVersion: skaffold/v4beta6
# kind: Config
# metadata:
#   name: bootstrap
# manifests:
#   rawYaml:
#     - kubernetes/bootstrap/rbac.yaml
# deploy:
#   kubectl: {}
---
apiVersion: skaffold/v4beta6
kind: Config
metadata:
  name: debug
manifests:
  rawYaml:
    - kubernetes/debug/debug-job.yaml
deploy:
  kubectl: {}





# ---
# apiVersion: skaffold/v4beta6
# kind: Config
# metadata:
#   name: loadgenerator
# requires:
#   - configs:
#       - template-fastapi-app
# build:
#   platforms: ["linux/amd64"]
#   artifacts:
#     - image: loadgenerator
#       context: src/loadgenerator
# manifests:
#   rawYaml:
#     - ./kubernetes-manifests/loadgenerator.yaml
# deploy:
#   kubectl: {}
# profiles:
#   - name: gcb
#     build:
#       googleCloudBuild:
#         diskSizeGb: 300
#         machineType: N1_HIGHCPU_32
#         timeout: 4000s
